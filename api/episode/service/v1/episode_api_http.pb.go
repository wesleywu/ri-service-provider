// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.3
// - protoc             (unknown)
// source: api/episode/service/v1/episode_api.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	proto "github.com/wesleywu/ri-service-provider/app/episode/service/proto"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationEpisodeCount = "/v1.Episode/Count"
const OperationEpisodeCreate = "/v1.Episode/Create"
const OperationEpisodeDelete = "/v1.Episode/Delete"
const OperationEpisodeDeleteMulti = "/v1.Episode/DeleteMulti"
const OperationEpisodeGet = "/v1.Episode/Get"
const OperationEpisodeList = "/v1.Episode/List"
const OperationEpisodeOne = "/v1.Episode/One"
const OperationEpisodeUpdate = "/v1.Episode/Update"
const OperationEpisodeUpsert = "/v1.Episode/Upsert"

type EpisodeHTTPServer interface {
	Count(context.Context, *proto.EpisodeCountReq) (*proto.EpisodeCountRes, error)
	Create(context.Context, *proto.EpisodeCreateReq) (*proto.EpisodeCreateRes, error)
	Delete(context.Context, *proto.EpisodeDeleteReq) (*proto.EpisodeDeleteRes, error)
	DeleteMulti(context.Context, *proto.EpisodeDeleteMultiReq) (*proto.EpisodeDeleteMultiRes, error)
	Get(context.Context, *proto.EpisodeGetReq) (*proto.EpisodeGetRes, error)
	List(context.Context, *proto.EpisodeListReq) (*proto.EpisodeListRes, error)
	One(context.Context, *proto.EpisodeOneReq) (*proto.EpisodeOneRes, error)
	Update(context.Context, *proto.EpisodeUpdateReq) (*proto.EpisodeUpdateRes, error)
	Upsert(context.Context, *proto.EpisodeUpsertReq) (*proto.EpisodeUpsertRes, error)
}

func RegisterEpisodeHTTPServer(s *http.Server, srv EpisodeHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/episode/count", _Episode_Count0_HTTP_Handler(srv))
	r.POST("/v1/episode/one", _Episode_One0_HTTP_Handler(srv))
	r.POST("/v1/episode/list", _Episode_List0_HTTP_Handler(srv))
	r.GET("/v1/episode/{id}", _Episode_Get0_HTTP_Handler(srv))
	r.POST("/v1/episode", _Episode_Create0_HTTP_Handler(srv))
	r.PATCH("/v1/episode/{id}", _Episode_Update0_HTTP_Handler(srv))
	r.PUT("/v1/episode/{id}", _Episode_Upsert0_HTTP_Handler(srv))
	r.DELETE("/v1/episode/{id}", _Episode_Delete0_HTTP_Handler(srv))
	r.POST("/v1/episode/delete", _Episode_DeleteMulti0_HTTP_Handler(srv))
}

func _Episode_Count0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeCountReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeCount)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Count(ctx, req.(*proto.EpisodeCountReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeCountRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_One0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeOneReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeOne)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.One(ctx, req.(*proto.EpisodeOneReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeOneRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_List0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeListReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.List(ctx, req.(*proto.EpisodeListReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeListRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_Get0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeGetReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeGet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Get(ctx, req.(*proto.EpisodeGetReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeGetRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_Create0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeCreate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Create(ctx, req.(*proto.EpisodeCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeCreateRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_Update0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeUpdate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Update(ctx, req.(*proto.EpisodeUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeUpdateRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_Upsert0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeUpsertReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeUpsert)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Upsert(ctx, req.(*proto.EpisodeUpsertReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeUpsertRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_Delete0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeDelete)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Delete(ctx, req.(*proto.EpisodeDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeDeleteRes)
		return ctx.Result(200, reply)
	}
}

func _Episode_DeleteMulti0_HTTP_Handler(srv EpisodeHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in proto.EpisodeDeleteMultiReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEpisodeDeleteMulti)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteMulti(ctx, req.(*proto.EpisodeDeleteMultiReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*proto.EpisodeDeleteMultiRes)
		return ctx.Result(200, reply)
	}
}

type EpisodeHTTPClient interface {
	Count(ctx context.Context, req *proto.EpisodeCountReq, opts ...http.CallOption) (rsp *proto.EpisodeCountRes, err error)
	Create(ctx context.Context, req *proto.EpisodeCreateReq, opts ...http.CallOption) (rsp *proto.EpisodeCreateRes, err error)
	Delete(ctx context.Context, req *proto.EpisodeDeleteReq, opts ...http.CallOption) (rsp *proto.EpisodeDeleteRes, err error)
	DeleteMulti(ctx context.Context, req *proto.EpisodeDeleteMultiReq, opts ...http.CallOption) (rsp *proto.EpisodeDeleteMultiRes, err error)
	Get(ctx context.Context, req *proto.EpisodeGetReq, opts ...http.CallOption) (rsp *proto.EpisodeGetRes, err error)
	List(ctx context.Context, req *proto.EpisodeListReq, opts ...http.CallOption) (rsp *proto.EpisodeListRes, err error)
	One(ctx context.Context, req *proto.EpisodeOneReq, opts ...http.CallOption) (rsp *proto.EpisodeOneRes, err error)
	Update(ctx context.Context, req *proto.EpisodeUpdateReq, opts ...http.CallOption) (rsp *proto.EpisodeUpdateRes, err error)
	Upsert(ctx context.Context, req *proto.EpisodeUpsertReq, opts ...http.CallOption) (rsp *proto.EpisodeUpsertRes, err error)
}

type EpisodeHTTPClientImpl struct {
	cc *http.Client
}

func NewEpisodeHTTPClient(client *http.Client) EpisodeHTTPClient {
	return &EpisodeHTTPClientImpl{client}
}

func (c *EpisodeHTTPClientImpl) Count(ctx context.Context, in *proto.EpisodeCountReq, opts ...http.CallOption) (*proto.EpisodeCountRes, error) {
	var out proto.EpisodeCountRes
	pattern := "/v1/episode/count"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeCount))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) Create(ctx context.Context, in *proto.EpisodeCreateReq, opts ...http.CallOption) (*proto.EpisodeCreateRes, error) {
	var out proto.EpisodeCreateRes
	pattern := "/v1/episode"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeCreate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) Delete(ctx context.Context, in *proto.EpisodeDeleteReq, opts ...http.CallOption) (*proto.EpisodeDeleteRes, error) {
	var out proto.EpisodeDeleteRes
	pattern := "/v1/episode/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEpisodeDelete))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) DeleteMulti(ctx context.Context, in *proto.EpisodeDeleteMultiReq, opts ...http.CallOption) (*proto.EpisodeDeleteMultiRes, error) {
	var out proto.EpisodeDeleteMultiRes
	pattern := "/v1/episode/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeDeleteMulti))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) Get(ctx context.Context, in *proto.EpisodeGetReq, opts ...http.CallOption) (*proto.EpisodeGetRes, error) {
	var out proto.EpisodeGetRes
	pattern := "/v1/episode/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEpisodeGet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) List(ctx context.Context, in *proto.EpisodeListReq, opts ...http.CallOption) (*proto.EpisodeListRes, error) {
	var out proto.EpisodeListRes
	pattern := "/v1/episode/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) One(ctx context.Context, in *proto.EpisodeOneReq, opts ...http.CallOption) (*proto.EpisodeOneRes, error) {
	var out proto.EpisodeOneRes
	pattern := "/v1/episode/one"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeOne))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) Update(ctx context.Context, in *proto.EpisodeUpdateReq, opts ...http.CallOption) (*proto.EpisodeUpdateRes, error) {
	var out proto.EpisodeUpdateRes
	pattern := "/v1/episode/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeUpdate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EpisodeHTTPClientImpl) Upsert(ctx context.Context, in *proto.EpisodeUpsertReq, opts ...http.CallOption) (*proto.EpisodeUpsertRes, error) {
	var out proto.EpisodeUpsertRes
	pattern := "/v1/episode/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEpisodeUpsert))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
